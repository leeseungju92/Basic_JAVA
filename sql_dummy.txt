DROP TABLE EMP;
DROP TABLE DEPT;
DROP TABLE BONUS;
DROP TABLE SALGRADE;
DROP TABLE DUMMY;
 
CREATE TABLE EMP
       (EMPNO NUMBER(4) PRIMARY KEY,
        ENAME VARCHAR2(10),
        JOB VARCHAR2(9),
        MGR NUMBER(4),
        HIREDATE DATE,
        SAL NUMBER(7, 2),
        COMM NUMBER(7, 2),
        DEPTNO NUMBER(2));
 
INSERT INTO EMP VALUES
        (7369, 'SMITH',  'CLERK',     7902,
        sysdate,  800, NULL, 20);
         
INSERT INTO EMP VALUES
        (7499, 'ALLEN',  'SALESMAN',  7698,
        sysdate, 1600,  300, 30);
         
INSERT INTO EMP VALUES
        (7521, 'WARD',   'SALESMAN',  7698,
        sysdate, 1250,  500, 30);
         
INSERT INTO EMP VALUES
        (7566, 'JONES',  'MANAGER',   7839,
        sysdate,  2975, NULL, 20);
         
INSERT INTO EMP VALUES
        (7654, 'MARTIN', 'SALESMAN',  7698,
        sysdate, 1250, 1400, 30);
         
INSERT INTO EMP VALUES
        (7698, 'BLAKE',  'MANAGER',   7839,
        sysdate,  2850, NULL, 30);
         
INSERT INTO EMP VALUES
        (7782, 'CLARK',  'MANAGER',   7839,
        sysdate,  2450, NULL, 10);
INSERT INTO EMP VALUES
        (7788, 'SCOTT',  'ANALYST',   7566,
        sysdate, 3000, NULL, 20);
         
INSERT INTO EMP VALUES
        (7839, 'KING',   'PRESIDENT', NULL,
        sysdate, 5000, NULL, 10);
         
INSERT INTO EMP VALUES
        (7844, 'TURNER', 'SALESMAN',  7698,
        sysdate,  1500,    0, 30);
         
INSERT INTO EMP VALUES
        (7876, 'ADAMS',  'CLERK',     7788,
        sysdate, 1100, NULL, 20);
         
INSERT INTO EMP VALUES
        (7900, 'JAMES',  'CLERK',     7698,
        sysdate,   950, NULL, 30);
         
INSERT INTO EMP VALUES
        (7902, 'FORD',   'ANALYST',   7566,
        sysdate,  3000, NULL, 20);
         
INSERT INTO EMP VALUES
        (7934, 'MILLER', 'CLERK',     7782,
        sysdate, 1300, NULL, 10);
 
CREATE TABLE DEPT
       (DEPTNO NUMBER(2) PRIMARY KEY,
        DNAME VARCHAR2(14),
        LOC VARCHAR2(13) );
 
INSERT INTO DEPT VALUES (10, 'ACCOUNTING', 'NEW YORK');
INSERT INTO DEPT VALUES (20, 'RESEARCH',   'DALLAS');
INSERT INTO DEPT VALUES (30, 'SALES',      'CHICAGO');
INSERT INTO DEPT VALUES (40, 'OPERATIONS', 'BOSTON');
 
CREATE TABLE BONUS
        (ENAME VARCHAR2(10),
         JOB   VARCHAR2(9),
         SAL   NUMBER,
         COMM  NUMBER);
 
CREATE TABLE SALGRADE
        (GRADE NUMBER,
         LOSAL NUMBER,
         HISAL NUMBER);
 
INSERT INTO SALGRADE VALUES (1,  700, 1200);
INSERT INTO SALGRADE VALUES (2, 1201, 1400);
INSERT INTO SALGRADE VALUES (3, 1401, 2000);
INSERT INTO SALGRADE VALUES (4, 2001, 3000);
INSERT INTO SALGRADE VALUES (5, 3001, 9999);
 
CREATE TABLE DUMMY
        (DUMMY NUMBER);
 
INSERT INTO DUMMY VALUES (0);
 
COMMIT;

SELECT * FROM emp;

DROP TABLE EMP;
DROP TABLE DEPT;
DROP TABLE BONUS;
DROP TABLE SALGRADE;
DROP TABLE DUMMY;
 
CREATE TABLE EMP
       (EMPNO NUMBER(4) PRIMARY KEY,
        ENAME VARCHAR2(10),
        JOB VARCHAR2(9),
        MGR NUMBER(4),
        HIREDATE DATE,
        SAL NUMBER(7, 2),
        COMM NUMBER(7, 2),
        DEPTNO NUMBER(2));
 
INSERT INTO EMP VALUES
        (7369, 'SMITH',  'CLERK',     7902,
        sysdate,  800, NULL, 20);
         
INSERT INTO EMP VALUES
        (7499, 'ALLEN',  'SALESMAN',  7698,
        sysdate, 1600,  300, 30);
         
INSERT INTO EMP VALUES
        (7521, 'WARD',   'SALESMAN',  7698,
        sysdate, 1250,  500, 30);
         
INSERT INTO EMP VALUES
        (7566, 'JONES',  'MANAGER',   7839,
        sysdate,  2975, NULL, 20);
         
INSERT INTO EMP VALUES
        (7654, 'MARTIN', 'SALESMAN',  7698,
        sysdate, 1250, 1400, 30);
         
INSERT INTO EMP VALUES
        (7698, 'BLAKE',  'MANAGER',   7839,
        sysdate,  2850, NULL, 30);
         
INSERT INTO EMP VALUES
        (7782, 'CLARK',  'MANAGER',   7839,
        sysdate,  2450, NULL, 10);
INSERT INTO EMP VALUES
        (7788, 'SCOTT',  'ANALYST',   7566,
        sysdate, 3000, NULL, 20);
         
INSERT INTO EMP VALUES
        (7839, 'KING',   'PRESIDENT', NULL,
        sysdate, 5000, NULL, 10);
         
INSERT INTO EMP VALUES
        (7844, 'TURNER', 'SALESMAN',  7698,
        sysdate,  1500,    0, 30);
         
INSERT INTO EMP VALUES
        (7876, 'ADAMS',  'CLERK',     7788,
        sysdate, 1100, NULL, 20);
         
INSERT INTO EMP VALUES
        (7900, 'JAMES',  'CLERK',     7698,
        sysdate,   950, NULL, 30);
         
INSERT INTO EMP VALUES
        (7902, 'FORD',   'ANALYST',   7566,
        sysdate,  3000, NULL, 20);
         
INSERT INTO EMP VALUES
        (7934, 'MILLER', 'CLERK',     7782,
        sysdate, 1300, NULL, 10);
 
CREATE TABLE DEPT
       (DEPTNO NUMBER(2) PRIMARY KEY,
        DNAME VARCHAR2(14),
        LOC VARCHAR2(13) );
 
INSERT INTO DEPT VALUES (10, 'ACCOUNTING', 'NEW YORK');
INSERT INTO DEPT VALUES (20, 'RESEARCH',   'DALLAS');
INSERT INTO DEPT VALUES (30, 'SALES',      'CHICAGO');
INSERT INTO DEPT VALUES (40, 'OPERATIONS', 'BOSTON');
 
CREATE TABLE BONUS
        (ENAME VARCHAR2(10),
         JOB   VARCHAR2(9),
         SAL   NUMBER,
         COMM  NUMBER);
 
CREATE TABLE SALGRADE
        (GRADE NUMBER,
         LOSAL NUMBER,
         HISAL NUMBER);
 
INSERT INTO SALGRADE VALUES (1,  700, 1200);
INSERT INTO SALGRADE VALUES (2, 1201, 1400);
INSERT INTO SALGRADE VALUES (3, 1401, 2000);
INSERT INTO SALGRADE VALUES (4, 2001, 3000);
INSERT INTO SALGRADE VALUES (5, 3001, 9999);
 
CREATE TABLE DUMMY
        (DUMMY NUMBER);
 
INSERT INTO DUMMY VALUES (0);
 
COMMIT;

SELECT * FROM emp;
SELECT * FROM dept;
--JOIN
--1.둘 이상의 테이블을 연결하여 하나의 가상테이블을 만드는 것
--2.보통 둘이상의 행들의 공통된 값 PK및 FK 값을 사용하여 조인한다.
--3.두개의 테이블을 SELECT 문장 안에서 조인하려면 적어도 하나의
--컬럼이 그 두 테이블 사이에서 공유되어야 한다.

--신입사원 반드시 하나이상의 부서에 소속되어야 한다.

--JOIN 종류
--1.Equi Join(동등조인)
--ex) dept 테이블과 emp 테이블을 조인
SELECT e.empno, e.ename as 사원이름, d.dname
FROM dept d, emp e
WHERE d.deptno = e.deptno;

--2.Inner Join = Equi Join
--ex) dept 테이블과 emp 테이블을 Inner 조인
--   ','대신에 INNER JOIN을 사용 (INNER 생략가능)
--WHERE 절이 ON 절로 바뀜 조인의 조건
SELECT e.empno, e.ename, d.dname
FROM emp e INNER JOIN dept d
ON d.deptno = e.deptno;
--3.NATURAL Join = Equi JOIN
--dept 테이블과 emp 테이블을 natural 조인
--동일한 칼럼을 내부적으로 모두 조인, on절(동등조건)이 생략가능
-- Natural 과 USING 은 같이 사용이 불가능 합니다.
-- Naturaljoin 에서 Using절을 사용하고 싶으면 Inner Join으로 변경하고 사용해야함
SELECT e.empno, e.ename, d.dname
FROM dept d
NATURAL JOIN emp e;
--USING (deptno); --동일한 이름을 가지는 컬럼은 모두 조인됨으로
                  --USING 을 사용하면 컬럼을 선택해서 조인 가능 
                  
--4. NON-EQUI JOIN
--테이블의 어떤 컬럼도 Join 할 테이블의 컬럼과 일치하지 않을때 사용
--조인 조건은 동등(=) 이외의 연산자를 사용합니다.
--BETWEEN AND, IS NULL, IS NOT NULL, IN , NOT IN

SELECT * FROM salgrade;

SELECT e.ename, e.sal, s.grade
FROM emp e , salgrade s
WHERE e.sal
BETWEEN s.losal
AND s.hisal;

--5.Self Join
-- Equi Join 과 같으나 하나의 테이블에서 조인이 일어난다는 것 이 다르다.
--같은 테이블에 대해 두개의 alias를 사용하여 FROM 절에 두개의 테이블 사용하는 것 처럼 조인
-- 사원의 매니저 이름을 조회하는 Self Join

SELECT e.ename, a.ename as Manager
FROM emp e, emp a
WHERE e.empno=a.mgr; 

SELECT e.ename, a.ename as Manager
FROM emp e, emp a;
--※Cartesian Product
--검색하고자 했던 데이터 뿐만 아니라 조인에 사용된 테이블들의 모든 데이터가 반환되는 현상
--cartesian product는 조인 조건을 정의하지 않는 경우 발생한다.
--CROSS JOIN 을 사용하면 Cartesian Product값을 얻을 수 있음
--ex) CROSS JOIN 절을 이용하여 Cartesian Product 값을 얻는 예제
SELECT e.empno, e.ename, d.dname
FROM dept d CROSS JOIN emp e;

--OUTER Join
-- Equi JOin 은 조인을 생성하려는 두 개의 테이블의 한쪽 커럶에서 값이 없다면 데이터를 반환하지 못함.
-- 동일 조건에서 조인 조건을 만족하는 값이 없는 행들을 조회하기 위해  Outer Join을 사용
-- Outer Join 연산자는 (+)이다.
-- 조인시 값이 없는 조인측에 (+)를 위치 시킨다.
-- Outer Join 연산자는 표현식의 한 편에만 올 수 있다.
-- ex) Equi Join과 Outer Join 비교
--      ex1)EqUI JOin 으로 부서번호를 조회
SELECT DISTINCT(e.deptno), d.deptno, d.dname
FROM emp e, dept d
WHERE e.deptno = d.deptno;
--      ex2)Outer join 으로 부서번호를 조회
SELECT DISTINCT(e.deptno), d.deptno, d.dname
FROM emp e, dept d
WHERE e.deptno(+)=d.deptno;

SELECT DISTINCT(e.deptno), d.deptno, d.dname
FROM dept d
LEFT OUTER JOIN emp e
on e.deptno=d.deptno;

SELECT DISTINCT(e.deptno), d.deptno, d.dname
FROM emp e
RIGHT OUTER JOIN dept d
on e.deptno=d.deptno;

SELECT DISTINCT(e.deptno), d.deptno, d.dname
FROM emp e

FULL OUTER JOIN dept d
ON e.deptno=d.deptno;

--COMMIT ROLLBACK

-- Oracle 내장 함수
-- : dual 테이블 
--  1.  Oracle 에서 자체적으로 제공하는 테이블
--  2.  간단하게 함수를 이용해서 계산 결과 값을 확인 할 때 사용
--  3.  SYS 사용자가 소유하는 Oracle의 표준 테이블
--  4.  SYS 사용자가 소유하지만 어느 사용자든 접근 가능
--  5.  오직 한행, 한컬럼만 담고 있는 dummy 테이블
-- : 용도
--  1. 사용자가함수를 실행할 때 임시로 사용하는데 적합
--  2. 함수에 대한 쓰임을 알고 싶을 때 특정 테이블 생성없이 dual을 사용하면 return받을 수 있음

-- ex)
SELECT SYSDATE FROM DUAL;

SELECT seq_sale.CURRVAL FROM DUAL;

SELECT seq_sale.NEXTVAL FROM DUAL;

--1.ABS 절대값을 반환하는 함수
SELECT ABS (-1.234) absolute FROM DUAL;

--1.CEIL 올림값을 반환하는 함수
SELECT CEIL(10.1234) ceil FROM DUAL;
--3. 플로어 버림
SELECT FLOOR(10.1234) FROM DUAL;
--4. 모드 9/4 나머지  나머지 0일경우 9반환
SELECT MOD(9, 4) FROM DUAL;
--5. 라운드 n값의  반올림을 하는 함수로 m은 소숫점 아래 자릿수를 나타냄
SELECT ROUND(192.153, 1) FROM DUAL;
SELECT ROUND(192.153,-1) FROM DUAL;
--6. 트런ㅋ n값을 절삭하는 함수 m은 소숫점 아래 자릿수를 나타냄
SELECT TRUNC(7.5997,2)FROM DUAL;
SELECT TRUNC(789.5597,-2)FROM DUAL;

--문자열함수
--1. CONCAT 두문자를 결합, '||'<= LIKE절
-- ex)'%'||keyword||'%'
SELECT CONCAT('www.','oracle.')||'com' FROM DUAL;

--2. INTICAP(char), LOWER(char), UPPER(char)
--  INITCAP : 주어진 문자열의 첫번쨰 문자를 대문자로
--  LOWER : 주어진 문자열을 소문자로 변환
--  UPPER : 주어진 문자열을 대문자로 변환
SELECT INITCAP('oracle') name FROM DUAL;
SELECT LOWER('oracle') name FROM DUAL;
SELECT UPPER('oracle') name FROM DUAL;

--3. LENGTH(char) LENTHB(char)
--문자열 길이를 반환
SELECT LENGTH('오라클자바') len FROM DUAL; --순수 글자수
SELECT LENGTHB('오라클자바') len FROM DUAL; --글자 바이트수

--4. REPLACE(char1, str1, str2)
--문자열의 특정 문자를 다른문자로 변환
SELECT REPLACE ('오라클자바', '오라클', '파이썬') FROM DUAL;

--5. INSTR(char1, str1, m, n)
--문자열이 포함되어 있는지 조사하여 문자열의 위치를 반환, 문자열이 발견되지 않으면 0이반환
--char1 : 지정문자 , str1 : 검색문자, m:시작위치, n:검색순위
SELECT INSTR('CORPORATE FLOOR', 'OK') FROM DUAL;
SELECT INSTR('CORPORATE FLOOR', 'OR') FROM DUAL;
SELECT INSTR('CORPORATE FLOOR', 'OR', 3, 2) idx FROM DUAL;

--6. TRIM
--특정한 문자를 제거, 제거할 문자를 입력하지 않으면 기본적으로 공백이 제거
SELECT TRIM('    오라클자바') FROM DUAL;
--집계함수

--  1.GROUP BY  절을 이용하여 그룹 당 하나의 결과로 그룹화 할 수 있다.
--  2.HAVING 절을 사용하여 집계함수를 이용한 조건 비교를 할 수 있다.
--  3.MIN, MAX 함수는 모든 자료형에 사용할 수 있다.

--  1. COUNT
-- 검색된 행의 수를 반환
SELECT COUNT(deptno)FROM dept;

--  2. MAX
-- 최대값 반환
SELECT MAX(sal) salary fROM emp;

--  3. MIN
SELECT MIN(sal) salary fROM emp;

--  4. SUM
SELECT SUM(sal) salrary
FROM emp
WHERE deptno = 30;

--  5. STDDEV :표준편차
SELECT ROUND(STDDEV(sal),3) salary
FROM emp
WHERE deptno= 30;

--집계함수 예 
SELECT deptno 부서번호, COUNT(*) 사원수,
        MAX(sal) 최대급여, MIN(sal) 최소급여,
        SUM(sal) 급여합계, ROUND(AVG(sal)) 평균급여
        FROM emp
        GROUP BY deptno
        ORDER BY SUM(sal) DESC;

-- SELECT의 GROUP BY 절
-- 1. 데이터를 원하는 그룹으로 나눌 수 있음
-- 2. 나누고자 하는 그룹의 컬럼명을 SELECT 절과 GRUOP BY 절 뒤에 추가하면 됨
-- 3. 집계함수와 함께 사용되는 상수는 GROUP BY 절에 추가하지 않아도 된다.

SELECT '2020년' year, deptno 부서번호, COUNT(*) 사원수
FROM emp
GROUP BY deptno
ORDER BY COUNT(*) DESC;

ex) 부서별로 그룹하여 부서번호, 인원수, 급여의 평균, 급여의 합을 조회

SELECT deptno 부서번호, COUNT(*) 사원수, SUM(sal) , FLOOR(AVG(sal)) 급여평균
FROM emp
GROUP BY deptno;

-- 셀렉트에 해빙절
-- 1. 웨어절에 집계함수를 사용할수 없음
-- 2. 해빙절은 그룹바이 절과 함께 사용
-- 3. 해빙절은 그룹바이 절과 함께 사용

--ex) 사원수가 다섯명이 넘는 부서와 사원수를 조회
SELECT d.dname, COUNT(e.empno) 사원수
FROM emp e, dept d 
WHERE e.deptno = d.deptno
GROUP BY dname
HAVING COUNT (e.empno)>=5
ORDER BY dname;

--view 테이블
--  1. 하나의 가상 테이블
--  2. 실제 데이터가 저장되는 것은 아니지만 뷰를 통해 데이터를 관리할 수 있음.
--  3. 복잡한 QUERY를 통해 얻을 수 있는 결과를 간단한 Query로 얻을 수 있음
--  4. 한 개의 뷰로 여러 테이블에 대한 데이터를 검색 할 수 있음.
--  5. View 설정값 FORCE : 기본테이블 유무에 관계없이 view 를 생성
--     WITH CHECK OPTION : view에 의해 액세스 될 수 있는 행만이 입력되거나 변경될 수 있음
--     WITH READ ONLY SELECT만 가능한 VIEW 생성

--CREATE [OR REPLACE] [FORCE|NOFORCE] VIEW view_name
--AS subquery
--[WITH CHECK OPTION] [CONSTRAINT 제약조건]
--[WITH READ ONLY]

CREATE OR REPLACE VIEW view_query
AS
    SELECT e.empno, e.ename, d.dname, d.loc
    FROM emp e, dept d
    WHERE e.deptno = d.deptno;   

SELECT * FROM view_query;

--인덱스
-- : 테이블 내에 원하는 레코드를 빠르게 찾아갈 수 있도록 만들어진 데이터 구조
-- : 오라클에서는 B-TREE를 기반으로 인덱스를 생성함
-- ※ 인덱스를 건다고 해서 무조건 성능이 좋아지는건 아님, 역으로 나빠질수도 있음

--자동인덱스: PK, UNIQUE 속성을 사용할때 자동으로 생성되는 인덱스
--수동인덱스: CREATE INDEX 명으로 직접 만든 인덱스
-- 인덱스를 사용하면 좋은 경우
-- 1. WHERE 절이나 JOIN 조건 안에서 자주 사용되는 컬럼
-- 2. NULL 값이 많이 포함되어 있는 컬럼
-- 3. WHERE 절이나 JOIN 조건에서 자주 사용되는 두개이상의 컬럼들


--인덱스를 사용하면 안좋은 경우
--1. 테이블이 작은경우(데이터가 작은 경우ㅠ)
--2. 테이블이 자주 갱신되는경우(값이INSERT, UPDATE,DELETE 되는 경우)

-- ex) UNIQUE 인덱스 생성
CREATE UNIQUE INDEX emp_ename_index
ON emp(ename);
DROP INDEX emp_ename_index;

--서브쿼리(Subquery)
--1. Subquery 는 다른 하나의 SQL 문장의 절에 NEXTEDED 된 SELECT 문장
-- SELECT UPDATE DELETE INSERT 와같은 DML 문과 CREATE TABLE 또는 VIEW의 WHERE절이나 HAVING절에 사용.
-- 보통 Subqurery는 Main Query 이전에 한번 실행된다.
-- Subquery는 괄호로 묶어야 한다.
-- 단일행 연산자(=,>,<,<=,>=,<>,!=)와 다중행 연산자(IN,NOT,ANY,ALL,EXISTS) 들이 서브쿼리에서 사용
-- Subquery는 연산자의 오른쪽에 위치해야 한다.

JOB이  'CLERK'인 사원의 이름과 직업을 조회
SELECT ename, job FROM emp WHERE job = 'CLERK';

--동선씨 직업 몰라
--동선씨 직업을 갖는 사람들을 조회: mainquery
-- 동선씨 직업 조회 : subqurey

SELECT ename,job,sal 
FROM emp
WHERE job = (SELECT job 
             FROM emp 
             WHERE ename = 'SMITH');
-- ex) 부서별로 가장 급여를 많이 받는 사원정보를 출력
SELECT ename, job, sal, deptno
FROM emp
WHERE sal IN (SELECT MAX(sal) 
              FROM emp GROUP BY deptno) ;


DROP SEQUENCE seq_board;
CREATE SEQUENCE seq_board
    START WITH 1
    INCREMENT BY 1
    NOCYCLE;
DROP TABLE tbl_board CASCADE CONSTRAINTS;
CREATE TABLE tbl_board(
    bno number(10, 0),
    type CHAR(4) NOT NULL,
    title VARCHAR2(200) NOT NULL,
    content VARCHAR2(4000) NOT NULL,
    writer VARCHAR2(50) NOT NULL,
    viewcnt NUMBER DEFAULT 0,
    replycnt NUMBER DEFAULT 0,
    goodcnt NUMBER DEFAULT 0,
    regdate DATE DEFAULT SYSDATE,
    updatedate DATE DEFAULT SYSDATE,
    show CHAR(1) DEFAULT 'y',
    ref NUMBER DEFAULT 1 ,
    re_step NUMBER DEFAULT 1,
    re_level NUMBER DEFAULT 0
);
ALTER TABLE tbl_board ADD CONSTRAINT pk_board
PRIMARY KEY (bno);

INSERT INTO tbl_board(bno, type, title, content, writer, viewcnt, replycnt, goodcnt)
VALUES(seq_board.NEXTVAL, 'free', '테스트', '내용','admin12', 0,0,0);
INSERT INTO tbl_board(bno, type, title, content, writer, viewcnt, replycnt, goodcnt)
VALUES(seq_board.NEXTVAL, 'free', '스트테', '내용3','admin16', 0,0,0 );
INSERT INTO tbl_board(bno, type, title, content, writer, viewcnt, replycnt, goodcnt)
VALUES(seq_board.NEXTVAL, 'free', '토스트', '내용4','admin17',0,0,0);
INSERT INTO tbl_board(bno, type, title, content, writer, viewcnt, replycnt, goodcnt)
VALUES(seq_board.NEXTVAL, 'free', '게스트', '용내','admin1', 0,0,0);
INSERT INTO tbl_board(bno, type, title, content, writer, viewcnt, replycnt, goodcnt)
VALUES(seq_board.NEXTVAL, 'free', '스트리밍', '용내254','admin18',0,0,0);
INSERT INTO tbl_board(bno, type, title, content, writer, viewcnt, replycnt, goodcnt)
VALUES(seq_board.NEXTVAL, 'free', '테스트', '내용','admin12', 0,0,0);
INSERT INTO tbl_board(bno, type, title, content, writer, viewcnt, replycnt, goodcnt)
VALUES(seq_board.NEXTVAL, 'free', '스트링', '문자열','admin15', 0,0,0);
INSERT INTO tbl_board(bno, type, title, content, writer, viewcnt, replycnt, goodcnt)
VALUES(seq_board.NEXTVAL, 'free', '구스트', '내용1251234','admin2', 0,0,0);
INSERT INTO tbl_board(bno, type, title, content, writer, viewcnt, replycnt, goodcntl)
VALUES(seq_board.NEXTVAL, 'free', '감스트', '동해물과 백두산이','admin1', 0,0,0);
INSERT INTO tbl_board(bno, type, title, content, writer, viewcnt, replycnt, goodcnt)
VALUES(seq_board.NEXTVAL, 'free', '고스트', '마르고닳도록','admin18',0,0,0);
INSERT INTO tbl_board(bno, type, title, content, writer, viewcnt, replycnt, goodcnt)
VALUES(seq_board.NEXTVAL, 'free', '스트릿', '하느님이 보우하사','admin', 0,0,0);
INSERT INTO tbl_board(bno, type, title, content, writer, viewcnt, replycnt, goodcnt)
VALUES(seq_board.NEXTVAL, 'free', '텍스트', '우리나라만세','admin12', 0,0,0);
commit;
SELECT * FROM tbl_board;
